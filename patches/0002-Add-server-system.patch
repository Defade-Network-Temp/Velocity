From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Hygon <hygon806@gmail.com>
Date: Tue, 23 Aug 2022 02:36:20 +0200
Subject: [PATCH] Add server system


diff --git a/api/src/main/java/com/velocitypowered/api/proxy/server/RegisteredServer.java b/api/src/main/java/com/velocitypowered/api/proxy/server/RegisteredServer.java
index 1766833ecaad8554dcc57f551bf13f8e1e6350fe..829e485df5cbc1d5b9c3ce4c70389a2c67b5bc27 100644
--- a/api/src/main/java/com/velocitypowered/api/proxy/server/RegisteredServer.java
+++ b/api/src/main/java/com/velocitypowered/api/proxy/server/RegisteredServer.java
@@ -11,6 +11,7 @@ import com.velocitypowered.api.proxy.Player;
 import com.velocitypowered.api.proxy.messages.ChannelMessageSink;
 import java.util.Collection;
 import java.util.concurrent.CompletableFuture;
+import net.defade.bismuth.core.servers.Server;
 import net.kyori.adventure.audience.Audience;
 
 /**
@@ -50,4 +51,8 @@ public interface RegisteredServer extends ChannelMessageSink, Audience {
    * @since 3.2.0
    */
   CompletableFuture<ServerPing> ping(PingOptions pingOptions);
+
+  Server getBismuthServer();
+
+  void setBismuthServer(Server server);
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
index 8c69010c2cc85b59bd3ec37ed8b25679c5817d53..745f663d1d04fd8b6404593999d6d4b798909b7f 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
@@ -94,6 +94,8 @@ import java.util.function.IntFunction;
 import java.util.stream.Collectors;
 import net.defade.bismuth.server.BismuthServer;
 import net.defade.velocity.listeners.ListenersManager;
+import net.defade.velocity.servers.ServersManager;
+import net.defade.velocity.utils.FileUtils;
 import net.kyori.adventure.audience.Audience;
 import net.kyori.adventure.audience.ForwardingAudience;
 import net.kyori.adventure.key.Key;
@@ -151,7 +153,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
   private final VelocityChannelRegistrar channelRegistrar = new VelocityChannelRegistrar();
   private ServerListPingHandler serverListPingHandler;
 
-  private final ListenersManager listenersManager = new ListenersManager();
+  private final ListenersManager listenersManager = new ListenersManager(this);
+  private ServersManager serversManager;
 
   VelocityServer(final ProxyOptions options) {
     pluginManager = new VelocityPluginManager(this);
@@ -236,6 +239,15 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
       return;
     }
 
+    try {
+      FileUtils.initFolders();
+    } catch (IOException exception) {
+      logger.error("Unable to create the folders.", exception);
+      LogManager.shutdown();
+      System.exit(1);
+      return;
+    }
+
     for (Map.Entry<String, String> entry : configuration.getServers().entrySet()) {
       servers.register(new ServerInfo(entry.getKey(), AddressUtil.parseAddress(entry.getValue())));
     }
@@ -263,6 +275,9 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     }
 
     Metrics.VelocityMetrics.startMetrics(this, configuration.getMetrics());
+
+    serversManager = new ServersManager(this);
+    serversManager.start();
   }
 
   private void registerTranslations() {
@@ -545,6 +560,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
         Thread.currentThread().interrupt();
       }
 
+      serversManager.stop("Proxy shutdown.");
+
       // Since we manually removed the shutdown hook, we need to handle the shutdown ourselves.
       LogManager.shutdown();
 
@@ -786,4 +803,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
   public ListenersManager getListenersManager() {
     return listenersManager;
   }
+
+  public ServersManager getServersManager() {
+    return serversManager;
+  }
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java b/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java
index 19cf6bef5e59d73f12438a126e8e6b7bc57fc37a..81d1f88851b8a99d4e2eb26f088ac348abc2bb73 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/config/VelocityConfiguration.java
@@ -35,13 +35,19 @@ import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.security.SecureRandom;
+import java.util.ArrayList;
 import java.util.Base64;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Random;
+import java.util.Set;
+import net.defade.bismuth.core.servers.GameType;
+import net.defade.bismuth.core.utils.NetworkInfos;
 import net.kyori.adventure.text.minimessage.MiniMessage;
 import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
 import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
@@ -90,15 +96,17 @@ public class VelocityConfiguration implements ProxyConfig {
   @Expose
   private boolean forceKeyAuthentication = true; // Added in 1.19
   private final Yokura yokura;
+  private final Network network;
 
   private VelocityConfiguration(Servers servers, ForcedHosts forcedHosts, Advanced advanced,
-      Query query, Metrics metrics, Yokura yokura) {
+      Query query, Metrics metrics, Yokura yokura, Network network) {
     this.servers = servers;
     this.forcedHosts = forcedHosts;
     this.advanced = advanced;
     this.query = query;
     this.metrics = metrics;
     this.yokura = yokura;
+    this.network = network;
   }
 
   private VelocityConfiguration(String bind, String motd, int showMaxPlayers, boolean onlineMode,
@@ -107,7 +115,7 @@ public class VelocityConfiguration implements ProxyConfig {
       boolean onlineModeKickExistingPlayers, PingPassthroughMode pingPassthrough,
       boolean enablePlayerAddressLogging, Servers servers, ForcedHosts forcedHosts,
       Advanced advanced, Query query, Metrics metrics, boolean forceKeyAuthentication,
-      Yokura yokura) {
+      Yokura yokura, Network network) {
     this.bind = bind;
     this.motd = motd;
     this.showMaxPlayers = showMaxPlayers;
@@ -126,6 +134,7 @@ public class VelocityConfiguration implements ProxyConfig {
     this.metrics = metrics;
     this.forceKeyAuthentication = forceKeyAuthentication;
     this.yokura = yokura;
+    this.network = network;
   }
 
   /**
@@ -153,26 +162,6 @@ public class VelocityConfiguration implements ProxyConfig {
           + "receive any support!");
     }
 
-    switch (playerInfoForwardingMode) {
-      case NONE:
-        logger.warn("Player info forwarding is disabled! All players will appear to be connecting "
-            + "from the proxy and will have offline-mode UUIDs.");
-        break;
-      case MODERN:
-      case BUNGEEGUARD:
-        if (forwardingSecret == null || forwardingSecret.length == 0) {
-          logger.error("You don't have a forwarding secret set. This is required for security.");
-          valid = false;
-        }
-        break;
-      default:
-        break;
-    }
-
-    if (servers.getServers().isEmpty()) {
-      logger.warn("You don't have any servers configured.");
-    }
-
     for (Map.Entry<String, String> entry : servers.getServers().entrySet()) {
       try {
         AddressUtil.parseAddress(entry.getValue());
@@ -182,28 +171,6 @@ public class VelocityConfiguration implements ProxyConfig {
       }
     }
 
-    for (String s : servers.getAttemptConnectionOrder()) {
-      if (!servers.getServers().containsKey(s)) {
-        logger.error("Fallback server " + s + " is not registered in your configuration!");
-        valid = false;
-      }
-    }
-
-    for (Map.Entry<String, List<String>> entry : forcedHosts.getForcedHosts().entrySet()) {
-      if (entry.getValue().isEmpty()) {
-        logger.error("Forced host '{}' does not contain any servers", entry.getKey());
-        valid = false;
-        continue;
-      }
-
-      for (String server : entry.getValue()) {
-        if (!servers.getServers().containsKey(server)) {
-          logger.error("Server '{}' for forced host '{}' does not exist", server, entry.getKey());
-          valid = false;
-        }
-      }
-    }
-
     try {
       getMotd();
     } catch (Exception e) {
@@ -303,6 +270,10 @@ public class VelocityConfiguration implements ProxyConfig {
     return forwardingSecret.clone();
   }
 
+  public void setForwardingSecret(byte[] forwardingSecret) {
+    this.forwardingSecret = forwardingSecret;
+  }
+
   @Override
   public Map<String, String> getServers() {
     return servers.getServers();
@@ -413,6 +384,14 @@ public class VelocityConfiguration implements ProxyConfig {
     return yokura.getBismuthPasswordHash();
   }
 
+  public NetworkInfos getNetworkInfos() {
+    return network;
+  }
+
+  public Set<GameType> getGameTypes() {
+    return yokura.getGameTypes();
+  }
+
   @Override
   public String toString() {
     return MoreObjects.toStringHelper(this)
@@ -449,12 +428,6 @@ public class VelocityConfiguration implements ProxyConfig {
       throw new RuntimeException("Default configuration file does not exist.");
     }
 
-    // Create the forwarding-secret file on first-time startup if it doesn't exist
-    Path defaultForwardingSecretPath = Path.of("forwarding.secret");
-    if (Files.notExists(path) && Files.notExists(defaultForwardingSecretPath)) {
-      Files.writeString(defaultForwardingSecretPath, generateRandomString(12));
-    }
-
     boolean mustResave = false;
     CommentedFileConfig config = CommentedFileConfig.builder(path)
         .defaultData(defaultConfigLocation)
@@ -472,56 +445,6 @@ public class VelocityConfiguration implements ProxyConfig {
       configVersion = 1.0;
     }
 
-    // Whether or not this config version is older than 2.0 which uses the deprecated
-    // "forwarding-secret" parameter
-    boolean legacyConfig = configVersion < 2.0;
-
-    String forwardingSecretString;
-    byte[] forwardingSecret;
-
-    // Handle the previous (version 1.0) config
-    // There is duplicate/old code here in effort to make the future commit which abandons legacy
-    // config handling easier to implement. All that would be required is removing the if statement
-    // here and keeping the contents of the else block (with slight tidying).
-    if (legacyConfig) {
-      logger.warn(
-          "You are currently using a deprecated configuration version. The \"forwarding-secret\""
-              + " parameter is a security hazard and was removed in config version 2.0."
-              + " You should rename your current \"velocity.toml\" to something else to allow"
-              + " Velocity to generate a config file for the new version. You may then configure "
-              + " that file as you normally would. The only differences are the config-version "
-              + "and \"forwarding-secret\" has been replaced by \"forwarding-secret-file\".");
-
-      // Default legacy handling
-      forwardingSecretString = System.getenv()
-          .getOrDefault("VELOCITY_FORWARDING_SECRET", config.get("forwarding-secret"));
-      if (forwardingSecretString == null || forwardingSecretString.isEmpty()) {
-        forwardingSecretString = generateRandomString(12);
-        config.set("forwarding-secret", forwardingSecretString);
-        mustResave = true;
-      }
-    } else {
-      // New handling
-      forwardingSecretString = System.getenv().getOrDefault("VELOCITY_FORWARDING_SECRET", "");
-      if (forwardingSecretString.isEmpty()) {
-        String forwardSecretFile = config.get("forwarding-secret-file");
-        Path secretPath = forwardSecretFile == null
-            ? defaultForwardingSecretPath
-            : Path.of(forwardSecretFile);
-        if (Files.exists(secretPath)) {
-          if (Files.isRegularFile(secretPath)) {
-            forwardingSecretString = String.join("", Files.readAllLines(secretPath));
-          } else {
-            throw new RuntimeException(
-                "The file " + forwardSecretFile + " is not a valid file or it is a directory.");
-          }
-        } else {
-          throw new RuntimeException("The forwarding-secret-file does not exist.");
-        }
-      }
-    }
-    forwardingSecret = forwardingSecretString.getBytes(StandardCharsets.UTF_8);
-
     if (configVersion == 1.0 || configVersion == 2.0) {
       config.set("force-key-authentication", config.getOrElse("force-key-authentication", true));
       config.setComment("force-key-authentication",
@@ -562,18 +485,16 @@ public class VelocityConfiguration implements ProxyConfig {
     }
 
     // Read the rest of the config
-    CommentedConfig serversConfig = config.get("servers");
-    CommentedConfig forcedHostsConfig = config.get("forced-hosts");
     CommentedConfig advancedConfig = config.get("advanced");
     CommentedConfig queryConfig = config.get("query");
     CommentedConfig metricsConfig = config.get("metrics");
     CommentedConfig yokuraConfig = config.get("yokura");
-    PlayerInfoForwarding forwardingMode = config.getEnumOrElse("player-info-forwarding-mode",
-        PlayerInfoForwarding.NONE);
+    CommentedConfig networkConfig = config.get("network");
+    PlayerInfoForwarding forwardingMode = PlayerInfoForwarding.MODERN;
     PingPassthroughMode pingPassthroughMode = config.getEnumOrElse("ping-passthrough",
         PingPassthroughMode.DISABLED);
 
-    String bind = config.getOrElse("bind", "0.0.0.0:25577");
+    String bind = config.getOrElse("bind", "0.0.0.0:25565");
     int maxPlayers = config.getIntOrElse("show-max-players", 500);
     Boolean onlineMode = config.getOrElse("online-mode", true);
     Boolean forceKeyAuthentication = config.getOrElse("force-key-authentication", true);
@@ -583,14 +504,6 @@ public class VelocityConfiguration implements ProxyConfig {
     Boolean kickExisting = config.getOrElse("kick-existing-players", false);
     Boolean enablePlayerAddressLogging = config.getOrElse("enable-player-address-logging", true);
 
-    // Throw an exception if the forwarding-secret file is empty and the proxy is using a
-    // forwarding mode that requires it.
-    if (forwardingSecret.length == 0
-        && (forwardingMode == PlayerInfoForwarding.MODERN
-        || forwardingMode == PlayerInfoForwarding.BUNGEEGUARD)) {
-      throw new RuntimeException("The forwarding-secret file must not be empty.");
-    }
-
     return new VelocityConfiguration(
         bind,
         motd,
@@ -599,17 +512,18 @@ public class VelocityConfiguration implements ProxyConfig {
         preventClientProxyConnections,
         announceForge,
         forwardingMode,
-        forwardingSecret,
+        new byte[0],
         kickExisting,
         pingPassthroughMode,
         enablePlayerAddressLogging,
-        new Servers(serversConfig),
-        new ForcedHosts(forcedHostsConfig),
+        new Servers(),
+        new ForcedHosts(),
         new Advanced(advancedConfig),
         new Query(queryConfig),
         new Metrics(metricsConfig),
         forceKeyAuthentication,
-        new Yokura(yokuraConfig)
+        new Yokura(yokuraConfig),
+        new Network(networkConfig)
     );
   }
 
@@ -629,12 +543,8 @@ public class VelocityConfiguration implements ProxyConfig {
 
   private static class Servers {
 
-    private Map<String, String> servers = ImmutableMap.of(
-        "lobby", "127.0.0.1:30066",
-        "factions", "127.0.0.1:30067",
-        "minigames", "127.0.0.1:30068"
-    );
-    private List<String> attemptConnectionOrder = ImmutableList.of("lobby");
+    private Map<String, String> servers = ImmutableMap.of();
+    private List<String> attemptConnectionOrder = Collections.synchronizedList(new ArrayList<>());
 
     private Servers() {
     }
@@ -701,11 +611,7 @@ public class VelocityConfiguration implements ProxyConfig {
 
   private static class ForcedHosts {
 
-    private Map<String, List<String>> forcedHosts = ImmutableMap.of(
-        "lobby.example.com", ImmutableList.of("lobby"),
-        "factions.example.com", ImmutableList.of("factions"),
-        "minigames.example.com", ImmutableList.of("minigames")
-    );
+    private Map<String, List<String>> forcedHosts = ImmutableMap.of();
 
     private ForcedHosts() {
     }
@@ -957,6 +863,8 @@ public class VelocityConfiguration implements ProxyConfig {
     private int bismuthPort = 9600;
     private byte[] bismuthPasswordHash = new byte[0];
 
+    private Set<GameType> gameTypes = new HashSet<>();
+
     private Yokura() {
     }
 
@@ -965,6 +873,11 @@ public class VelocityConfiguration implements ProxyConfig {
         this.bismuthHost = config.getOrElse("bismuth-host", "0.0.0.0");
         this.bismuthPort = config.getOrElse("bismuth-port", 9600);
         this.bismuthPasswordHash = Base64.getDecoder().decode(config.getOrElse("bismuth-password", ""));
+
+        ArrayList<CommentedConfig> games = config.get("games");
+        for (CommentedConfig game : games) {
+          gameTypes.add(new GameType(game.get("game-name"), game.get("game-type")));
+        }
       }
     }
 
@@ -979,5 +892,24 @@ public class VelocityConfiguration implements ProxyConfig {
     public byte[] getBismuthPasswordHash() {
       return bismuthPasswordHash;
     }
+
+    public Set<GameType> getGameTypes() {
+      return gameTypes;
+    }
+  }
+
+  private static class Network extends NetworkInfos {
+
+    public Network(CommentedConfig config) {
+      super(
+              config.getOrElse("mongo-host", "127.0.0.1"),
+              config.getOrElse("mongo-port", 27017),
+              config.getOrElse("mongo-username", "Defade"),
+              config.getOrElse("mongo-database", "Defade"),
+              config.getOrElse("mongo-password", ""),
+              config.getOrElse("default-endermites", 200.0),
+              config.getOrElse("default-crystals", 10.0)
+      );
+    }
   }
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/server/VelocityRegisteredServer.java b/proxy/src/main/java/com/velocitypowered/proxy/server/VelocityRegisteredServer.java
index 57780110b032abf6ed375efd679551f5363f7b14..4e36fd920354a041cb97ff8821aaf7d00b502596 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/server/VelocityRegisteredServer.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/server/VelocityRegisteredServer.java
@@ -54,6 +54,7 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
+import net.defade.bismuth.core.servers.Server;
 import net.kyori.adventure.audience.Audience;
 import net.kyori.adventure.audience.ForwardingAudience;
 import org.checkerframework.checker.nullness.qual.NonNull;
@@ -67,6 +68,7 @@ public class VelocityRegisteredServer implements RegisteredServer, ForwardingAud
   private final @Nullable VelocityServer server;
   private final ServerInfo serverInfo;
   private final Map<UUID, ConnectedPlayer> players = new ConcurrentHashMap<>();
+  private Server bismuthServer;
 
   public VelocityRegisteredServer(@Nullable VelocityServer server, ServerInfo serverInfo) {
     this.server = server;
@@ -138,6 +140,16 @@ public class VelocityRegisteredServer implements RegisteredServer, ForwardingAud
     return pingFuture;
   }
 
+  @Override
+  public Server getBismuthServer() {
+    return bismuthServer;
+  }
+
+  @Override
+  public void setBismuthServer(Server server) {
+    this.bismuthServer = server;
+  }
+
   public void addPlayer(ConnectedPlayer player) {
     players.put(player.getUniqueId(), player);
   }
diff --git a/proxy/src/main/java/net/defade/velocity/listeners/ListenersManager.java b/proxy/src/main/java/net/defade/velocity/listeners/ListenersManager.java
index 69ef4cea04f5c515886f0d251b274cfa043de5e7..4877d9aa1fe4ff1fa2825bb04df26be360c3ed9b 100644
--- a/proxy/src/main/java/net/defade/velocity/listeners/ListenersManager.java
+++ b/proxy/src/main/java/net/defade/velocity/listeners/ListenersManager.java
@@ -17,6 +17,7 @@
 
 package net.defade.velocity.listeners;
 
+import com.velocitypowered.proxy.VelocityServer;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -30,9 +31,11 @@ import net.defade.bismuth.core.utils.NetworkInfos;
 import net.defade.bismuth.core.utils.ServerInfosProvider;
 
 public class ListenersManager implements ServerInfosProvider {
+  private final VelocityServer velocityServer;
   private final Map<ConnectionProtocol, Set<ServerPacketListener>> listeners = new HashMap<>();
 
-  public ListenersManager() {
+  public ListenersManager(VelocityServer velocityServer) {
+    this.velocityServer = velocityServer;
 
     for (ConnectionProtocol protocols : ConnectionProtocol.values()) {
       if (protocols == ConnectionProtocol.LOGIN) {
@@ -55,7 +58,7 @@ public class ListenersManager implements ServerInfosProvider {
   public ServerPacketListener getPacketListenerFromProtocol(ConnectionProtocol connectionProtocol) {
     switch (connectionProtocol) {
       case YOKURA:
-        YokuraListener yokuraListener = new YokuraListener();
+        YokuraListener yokuraListener = new YokuraListener(velocityServer);
         listeners.get(connectionProtocol).add(yokuraListener);
         return yokuraListener;
 
@@ -66,11 +69,11 @@ public class ListenersManager implements ServerInfosProvider {
 
   @Override
   public NetworkInfos getNetworkInfos() {
-    return null;
+    return velocityServer.getConfiguration().getNetworkInfos();
   }
 
   @Override
   public Server getServer(GameType gameType, String velocityIdTracker) {
-    return null;
+    return velocityServer.getServersManager().getServer(gameType, velocityIdTracker);
   }
 }
diff --git a/proxy/src/main/java/net/defade/velocity/listeners/YokuraListener.java b/proxy/src/main/java/net/defade/velocity/listeners/YokuraListener.java
index 887f292b99280fb3cfd037758e0cb4b129c5a2de..a0e3d3547663561cc4ba01e9acfdb5d324026877 100644
--- a/proxy/src/main/java/net/defade/velocity/listeners/YokuraListener.java
+++ b/proxy/src/main/java/net/defade/velocity/listeners/YokuraListener.java
@@ -17,8 +17,50 @@
 
 package net.defade.velocity.listeners;
 
+import com.velocitypowered.api.proxy.server.RegisteredServer;
+import com.velocitypowered.proxy.VelocityServer;
+import java.util.HashSet;
+import java.util.Set;
 import net.defade.bismuth.core.listeners.server.YokuraServerPacketListener;
+import net.defade.bismuth.core.protocol.ConnectionProtocol;
+import net.defade.bismuth.core.protocol.packets.yokura.client.ClientboundForwardingKeyPacket;
+import net.defade.bismuth.core.protocol.packets.yokura.client.ClientboundServersListPacket;
+import net.defade.bismuth.core.protocol.packets.yokura.client.ClientboundUpdateServerStatusPacket;
+import net.defade.bismuth.core.protocol.packets.yokura.server.ServerboundUpdateServerStatusPacket;
+import net.defade.bismuth.core.servers.Server;
 
 public class YokuraListener extends YokuraServerPacketListener {
+  private final VelocityServer velocityServer;
+  private final ListenersManager listenersManager;
 
+  public YokuraListener(VelocityServer velocityServer) {
+    this.velocityServer = velocityServer;
+    this.listenersManager = velocityServer.getListenersManager();
+  }
+
+  @Override
+  public void updateServerStatus(ServerboundUpdateServerStatusPacket updateServerStatusPacket) {
+    super.updateServerStatus(updateServerStatusPacket);
+
+    var packet = new ClientboundUpdateServerStatusPacket(getServer(), getServer().getServerStatus());
+    listenersManager.sendPacketForProtocol(ConnectionProtocol.YOKURA, packet);
+  }
+
+  @Override
+  public void channelActive() {
+    velocityServer.getServersManager().registerServer(getServer(), getAddress());
+    sendPacket(new ClientboundForwardingKeyPacket(velocityServer.getServersManager().getForwardingKey()));
+
+    Set<Server> servers = new HashSet<>();
+    for (RegisteredServer server : velocityServer.getAllServers()) {
+      servers.add(server.getBismuthServer());
+    }
+
+    sendPacket(new ClientboundServersListPacket(servers));
+  }
+
+  @Override
+  public void channelInactive() {
+    velocityServer.getServersManager().unregisterServer(getServer());
+  }
 }
diff --git a/proxy/src/main/java/net/defade/velocity/servers/ServersManager.java b/proxy/src/main/java/net/defade/velocity/servers/ServersManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..5d4ab5332031c8d13193b3ee69c40cde0cbdb2bb
--- /dev/null
+++ b/proxy/src/main/java/net/defade/velocity/servers/ServersManager.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2018 Velocity Contributors
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package net.defade.velocity.servers;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.velocitypowered.api.proxy.server.RegisteredServer;
+import com.velocitypowered.api.proxy.server.ServerInfo;
+import com.velocitypowered.proxy.VelocityServer;
+import com.velocitypowered.proxy.config.VelocityConfiguration;
+import java.io.File;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.atomic.AtomicInteger;
+import net.defade.bismuth.core.protocol.ConnectionProtocol;
+import net.defade.bismuth.core.protocol.packets.yokura.client.ClientboundCreatedServerPacket;
+import net.defade.bismuth.core.protocol.packets.yokura.client.ClientboundForwardingKeyPacket;
+import net.defade.bismuth.core.protocol.packets.yokura.client.ClientboundStopServerPacket;
+import net.defade.bismuth.core.servers.GameType;
+import net.defade.bismuth.core.servers.Server;
+import net.defade.bismuth.core.servers.ServerStatus;
+import net.defade.velocity.listeners.ListenersManager;
+import net.defade.velocity.utils.FileUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServersManager {
+  private static final Logger LOGGER = LogManager.getLogger(ServersManager.class);
+
+  private final VelocityServer velocityServer;
+  private final VelocityConfiguration velocityConfiguration;
+  private final ListenersManager listenersManager;
+
+  private final ExecutorService serverCreationThreadPool = Executors.newFixedThreadPool(2,
+          new ThreadFactoryBuilder().setNameFormat("Server Creation Thread #").build());
+  private final Timer timer = new Timer("Server manager Scheduler");
+
+  private final Map<String, GameType> awaitingServers = new HashMap<>();
+  private final Map<String, Process> awaitingServersProcess = new HashMap<>();
+
+  private final AtomicInteger serverIdProvider = new AtomicInteger(0);
+  private final byte[] forwardingKey = new byte[256];
+
+  private boolean isStopping = false;
+  private final CompletableFuture<Void> stopFuture = new CompletableFuture<>();
+
+  public ServersManager(VelocityServer velocityServer) {
+    this.velocityServer = velocityServer;
+    this.velocityConfiguration = velocityServer.getConfiguration();
+    this.listenersManager = velocityServer.getListenersManager();
+  }
+
+  public void start() {
+    timer.scheduleAtFixedRate(new TimerTask() {
+      @Override
+      public void run() {
+        ThreadLocalRandom.current().nextBytes(forwardingKey);
+        ClientboundForwardingKeyPacket forwardingKeyPacket = new ClientboundForwardingKeyPacket(forwardingKey);
+        listenersManager.sendPacketForProtocol(ConnectionProtocol.YOKURA, forwardingKeyPacket);
+        velocityConfiguration.setForwardingSecret(forwardingKey);
+
+        for (GameType gameTypes : velocityConfiguration.getGameTypes()) {
+          boolean gameTypeMatches = false;
+          for (RegisteredServer server : velocityServer.getAllServers()) {
+            if (server.getBismuthServer().getGameType().equals(gameTypes)) {
+              gameTypeMatches = true;
+              break;
+            }
+          }
+
+          if (gameTypeMatches || awaitingServers.containsValue(gameTypes)) {
+            continue;
+          }
+
+          String startingServer = null;
+          for (Map.Entry<String, GameType> entry : awaitingServers.entrySet()) {
+            if (entry.getValue().equals(gameTypes)) {
+              startingServer = entry.getKey();
+              break;
+            }
+          }
+
+          if (startingServer == null || !awaitingServersProcess.get(startingServer).isAlive()) {
+            awaitingServers.remove(startingServer);
+            awaitingServersProcess.remove(startingServer);
+
+            serverCreationThreadPool.submit(() -> createServer(gameTypes));
+          }
+        }
+      }
+    }, 0, 2000);
+  }
+
+  private void createServer(GameType gameType) {
+    String serverId = gameType.toString() + serverIdProvider.getAndIncrement();
+
+    Path serverPath = Paths.get(FileUtils.TEMP_SERVERS_FOLDER + File.separator + serverId);
+    try {
+      Files.createDirectory(serverPath);
+
+      Files.copy(FileUtils.SERVER_JAR, Paths.get(serverPath + File.separator + "yokura.jar"));
+      Files.copy(FileUtils.SERVER_BISMUTH_PASS, Paths.get(serverPath + File.separator + "bismuth.password"));
+      Path serverExtensionFolder = Paths.get(serverPath + File.separator + "extensions");
+      Files.createDirectory(serverExtensionFolder);
+      for (Path extension : FileUtils.getFiles(FileUtils.SERVERS_EXTENSIONS_FOLDER + File.separator + gameType)) {
+        FileUtils.copyPath(extension, serverExtensionFolder);
+      }
+
+    } catch (IOException exception) {
+      LOGGER.error("Couldn't copy the folders for the server " + serverId + ".", exception);
+      return;
+    }
+
+    ProcessBuilder processBuilder = new ProcessBuilder();
+    processBuilder.directory(serverPath.toFile());
+    processBuilder.command(
+            "java",
+            "-jar",
+            FileUtils.SERVER_JAR.getFileName().toString(),
+            "--velocity-id-tracker=" + serverId);
+    Process process;
+    try {
+      process = processBuilder.start();
+      awaitingServersProcess.put(serverId, process);
+    } catch (IOException exception) {
+      LOGGER.error("Couldn't start the server " + serverId + ".", exception);
+      return;
+    }
+    awaitingServers.put(serverId, gameType);
+
+    LOGGER.info("Created a " + gameType + " server.");
+  }
+
+  public void registerServer(Server server, InetSocketAddress address) {
+    try {
+      awaitingServers.remove(server.getServerId());
+      awaitingServersProcess.remove(server.getServerId());
+
+      RegisteredServer registeredServer = velocityServer.registerServer(new ServerInfo(server.getServerId(), address));
+      registeredServer.setBismuthServer(server);
+
+      if (server.getGameType().getMiniGame().contains("hub")) {
+        velocityConfiguration.getAttemptConnectionOrder().add(server.getServerId());
+      }
+
+      ClientboundCreatedServerPacket createdServerPacket = new ClientboundCreatedServerPacket(server);
+      listenersManager.sendPacketForProtocol(ConnectionProtocol.YOKURA, createdServerPacket);
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+
+  public void unregisterServer(Server server) {
+    RegisteredServer registeredServer = velocityServer.getServer(server.getServerId()).orElseThrow();
+
+    velocityServer.unregisterServer(registeredServer.getServerInfo());
+    velocityConfiguration.getAttemptConnectionOrder().remove(registeredServer.getServerInfo().getName());
+
+    LOGGER.info("Unregistered the " + registeredServer.getServerInfo().getName() + " server.");
+
+    if (isStopping && velocityServer.getAllServers().isEmpty()) {
+      stopFuture.complete(null);
+    }
+  }
+
+  public void stop(String reason) {
+    isStopping = true;
+    timer.cancel();
+
+    LOGGER.info("Stopping servers...");
+
+    ClientboundStopServerPacket stopServerPacket = new ClientboundStopServerPacket(reason);
+    listenersManager.sendPacketForProtocol(ConnectionProtocol.YOKURA, stopServerPacket);
+
+    try {
+      stopFuture.get();
+    } catch (InterruptedException | ExecutionException exception) {
+      LOGGER.warn("An exception has occurred whilst stopping servers.", exception);
+    }
+
+    LOGGER.info("Servers stopped.");
+  }
+
+  public byte[] getForwardingKey() {
+    return forwardingKey;
+  }
+
+  public Server getServer(GameType gameType, String velocityIdTracker) {
+    String serverId = velocityIdTracker;
+    if (serverId == null) {
+      serverId = gameType.toString() + serverIdProvider.getAndIncrement();
+    }
+
+    return new Server(serverId, gameType, ServerStatus.ACCEPTING_PLAYERS);
+  }
+}
diff --git a/proxy/src/main/java/net/defade/velocity/utils/FileUtils.java b/proxy/src/main/java/net/defade/velocity/utils/FileUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..2eb387c69fa138fa566214b347933b2cb68a484f
--- /dev/null
+++ b/proxy/src/main/java/net/defade/velocity/utils/FileUtils.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2018 Velocity Contributors
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package net.defade.velocity.utils;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class FileUtils {
+  public static final Path SERVERS_ROOT_FOLDER = Paths.get("servers");
+  public static final Path SERVER_JAR = Paths.get(SERVERS_ROOT_FOLDER + File.separator + "yokura.jar");
+  public static final Path SERVER_BISMUTH_PASS = Paths.get(SERVERS_ROOT_FOLDER + File.separator + "bismuth.password");
+  public static final Path TEMP_SERVERS_FOLDER = Paths.get(SERVERS_ROOT_FOLDER + File.separator + "temp");
+  public static final Path SERVERS_EXTENSIONS_FOLDER = Paths.get(SERVERS_ROOT_FOLDER + File.separator + "extensions");
+
+  public static void initFolders() throws IOException {
+    createFolderIfNotExists(SERVERS_ROOT_FOLDER);
+    createFolderIfNotExists(SERVERS_EXTENSIONS_FOLDER);
+
+    if (Files.exists(TEMP_SERVERS_FOLDER)) {
+      FileUtils.deletePath(TEMP_SERVERS_FOLDER);
+    }
+
+    Files.createDirectory(TEMP_SERVERS_FOLDER);
+  }
+
+  public static void deletePath(Path path) throws IOException {
+    try (Stream<Path> files = Files.list(path)) {
+      for (Path file : files.collect(Collectors.toList())) {
+        if (Files.isDirectory(file)) {
+          deletePath(file);
+        } else {
+          Files.delete(file);
+        }
+      }
+    }
+
+    Files.delete(path);
+  }
+
+  public static void copyPath(Path source, Path destination) throws IOException {
+    Files.copy(source, Paths.get(destination + File.separator + source.getFileName()));
+    if (Files.isDirectory(source)) {
+      try (Stream<Path> files = Files.list(source)) {
+        for (Path file : files.collect(Collectors.toList())) {
+          copyPath(file, Paths.get(destination + File.separator + source.getFileName()));
+        }
+      }
+    }
+  }
+
+  public static List<Path> getFiles(String path) throws IOException {
+    return getFiles(Paths.get(path));
+  }
+
+  public static List<Path> getFiles(Path path) throws IOException {
+    try (Stream<Path> files = Files.list(path)) {
+      return files.collect(Collectors.toList());
+    }
+  }
+
+  private static void createFolderIfNotExists(Path path) throws IOException {
+    if (!Files.exists(path)) {
+      Files.createDirectory(path);
+    }
+  }
+}
diff --git a/proxy/src/main/resources/default-velocity.toml b/proxy/src/main/resources/default-velocity.toml
index c911d407a38242b9c6ffc6ce768e03c01e984d5c..6341b776bdcd4d9c4fe3275db4abed00184e41ec 100644
--- a/proxy/src/main/resources/default-velocity.toml
+++ b/proxy/src/main/resources/default-velocity.toml
@@ -2,7 +2,7 @@
 config-version = "2.6"
 
 # What port should the proxy be bound to? By default, we'll bind to all addresses on port 25577.
-bind = "0.0.0.0:25577"
+bind = "0.0.0.0:25565"
 
 # What should be the MOTD? This gets displayed when the player adds your server to
 # their server list. Only MiniMessage format is accepted.
@@ -23,23 +23,6 @@ force-key-authentication = true
 # connections but is a weak form of protection.
 prevent-client-proxy-connections = false
 
-# Should we forward IP addresses and other data to backend servers?
-# Available options:
-# - "none":        No forwarding will be done. All players will appear to be connecting
-#                  from the proxy and will have offline-mode UUIDs.
-# - "legacy":      Forward player IPs and UUIDs in a BungeeCord-compatible format. Use this
-#                  if you run servers using Minecraft 1.12 or lower.
-# - "bungeeguard": Forward player IPs and UUIDs in a format supported by the BungeeGuard
-#                  plugin. Use this if you run servers using Minecraft 1.12 or lower, and are
-#                  unable to implement network level firewalling (on a shared host).
-# - "modern":      Forward player IPs and UUIDs as part of the login process using
-#                  Velocity's native forwarding. Only applicable for Minecraft 1.13 or higher.
-player-info-forwarding-mode = "NONE"
-
-# If you are using modern or BungeeGuard IP forwarding, configure a file that contains a unique secret here.
-# The file is expected to be UTF-8 encoded and not empty.
-forwarding-secret-file = "forwarding.secret"
-
 # Announce whether or not your server supports Forge. If you run a modded server, we
 # suggest turning this on.
 # 
@@ -69,30 +52,6 @@ ping-passthrough = "DISABLED"
 # If not enabled (default is true) player IP addresses will be replaced by <ip address withheld> in logs
 enable-player-address-logging = true
 
-[servers]
-# Configure your servers here. Each key represents the server's name, and the value
-# represents the IP address of the server to connect to.
-lobby = "127.0.0.1:30066"
-factions = "127.0.0.1:30067"
-minigames = "127.0.0.1:30068"
-
-# In what order we should try servers when a player logs in or is kicked from a server.
-try = [
-    "lobby"
-]
-
-[forced-hosts]
-# Configure your forced hosts here.
-"lobby.example.com" = [
-    "lobby"
-]
-"factions.example.com" = [
-    "factions"
-]
-"minigames.example.com" = [
-    "minigames"
-]
-
 [advanced]
 # How large a Minecraft packet has to be before we compress it. Setting this to zero will
 # compress all packets, and setting it to -1 will disable compression entirely.
@@ -162,4 +121,19 @@ bismuth-host = "0.0.0.0"
 bismuth-port = 9600
 
 # The password for bismuth, encrypted in SHA256 and encoded in base64.
-bismuth-password = ""
\ No newline at end of file
+bismuth-password = ""
+
+games = [
+    {game-name = "hub", game-type = "default"}
+]
+
+[network]
+
+mongo-host = "127.0.0.1"
+mongo-port = 27017
+mongo-username = "Defade"
+mongo-database = "Defade"
+mongo-password = ""
+
+default-endermites = 200.0
+default-crystals = 10.0
\ No newline at end of file
